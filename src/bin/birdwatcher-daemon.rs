#![feature(never_type)]

use std::{
    io::Write,
    path::{Path, PathBuf},
    sync::Arc,
};

use fs_err::PathExt;
use tokio::{net::UnixListener, process::Command, task::JoinSet, time::timeout};

use birdwatcher_rs::{
    config::Config, rpc::common::Insight, rpc::server::InsightServer, service::ServiceState,
};

use clap::Parser;

use color_eyre::{
    eyre::{eyre, Context as _},
    Result,
};

use futures::prelude::*;

use tarpc::{
    server::{BaseChannel, Channel},
    tokio_serde::formats::Bincode,
    tokio_util::codec::LengthDelimitedCodec,
};

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    /// Sets a custom config file
    #[arg(short, long, value_name = "FILE")]
    config: PathBuf,
}

/// A message send by a Service task to the main task
struct ServiceCommandResult {
    service_id: usize,
    success: bool,
}

#[tokio::main(flavor = "current_thread")]
async fn main() -> Result<()> {
    let cli = Cli::parse();

    let config: Config = Config::load_from_file(&cli.config)
        .wrap_err(format!("Failed to load config file {:?}", cli.config))?;

    // Contains the only mutable state: a counter for each service
    let service_states: Vec<ServiceState> = config
        .service_definitions
        .iter()
        .map(|def|
            // Start with all services disabled, but only one success is enough to switch to `Success`
            ServiceState::Failure {
                nb_of_success: def.rise - 1,
        })
        .collect();
    let service_states = Arc::new(std::sync::Mutex::new(service_states));
    let config = Arc::new(config);

    let pid_path = "/tmp/birdwatcher.pid";
    match fs_err::read_to_string(pid_path) {
        Ok(stored_pid) => {
            let stored_pid = stored_pid.trim();
            let another_bw_is_running =
                std::path::Path::new(&format!("/proc/{stored_pid}")).fs_err_try_exists()?;
            if another_bw_is_running {
                eprint!("Another birdwatcher with PID {stored_pid} is already running");
                std::process::exit(1);
            } else {
                fs_err::write(pid_path, format!("{}\n", std::process::id()))?;
            }
        }
        Err(e) => {
            if let std::io::ErrorKind::NotFound = e.kind() {
                fs_err::write(pid_path, format!("{}\n", std::process::id()))?;
            } else {
                return Err(e).context(format!(
                    "Trying to know if another birdwatcher is running by looking at PID file `{pid_path}`",
                ));
            }
        }
    };

    let socket_path = "/tmp/birdwatcher.sock";
    match std::fs::remove_file(socket_path) {
        Ok(_) => {}
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => {}
        Err(e) => return Err(e).context(format!("Cannot remove file {socket_path}")),
    }

    let listener = UnixListener::bind(&Path::new(socket_path)).unwrap();

    async fn spawn(fut: impl Future<Output = ()> + Send + 'static) {
        println!("spawning");
        tokio::spawn(fut);
    }
    let services_states_for_server = service_states.clone();
    let config_for_server = config.clone();

    let codec_builder = LengthDelimitedCodec::builder();

    tokio::spawn(async move {
        loop {
            let (conn, _addr) = listener.accept().await.unwrap();
            let framed = codec_builder.new_framed(conn);
            let transport = tarpc::serde_transport::new(framed, Bincode::default());

            let server = InsightServer {
                // socket: channel.transport().peer_addr().unwrap(),
                service_states: services_states_for_server.clone(),
                config: config_for_server.clone(),
            };
            let fut = BaseChannel::with_defaults(transport)
                .execute(server.serve())
                .for_each(spawn);
            tokio::spawn(fut);
        }
    });
    /*
    let li = listener
        // Ignore accept errors.
        // .filter_map(|r| future::ready(r.ok()))
        .map(server::BaseChannel::with_defaults)
        // Limit channels to 1 per IP.
        // .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated World trait.
        .map(move |channel| {
            let server = InsightServer {
                socket: channel.transport().peer_addr().unwrap(),
                service_states: services_states_for_server.clone(),
                config: config_for_server.clone(),
            };
            channel.execute(server.serve()).for_each(spawn)
        })
        // Max 10 channels.
        .buffer_unordered(10)
        .for_each(|_| async {});
    tokio::task::spawn(async {
        li.await;
    }); */

    write_bird_function(&config, &service_states.lock().unwrap());
    launch_reload_function(&config).await;

    let (tx, rx) = tokio::sync::mpsc::channel(1);

    let mut join_set = JoinSet::new();

    config
        .service_definitions
        .iter()
        .enumerate()
        .for_each(|(service_nb, service_def)| {
            println!("Starting {}", service_def.function_name);
            let service_def = service_def.clone();

            let tx = tx.clone();

            join_set.spawn(async move {
                loop {
                    println!(
                        "Regen function {}, Launching command {}",
                        service_def.function_name, service_def.command
                    );
                    let command = tokio::process::Command::new(service_def.command.clone())
                        .args(&service_def.args)
                        .output();
                    let result = timeout(service_def.command_timeout, command).await;
                    let return_value = match result {
                        Err(..) => {
                            println!("Command timed out");
                            false
                        }
                        Ok(Ok(o)) => o.status.success(),
                        Ok(Err(e)) => {
                            println!(
                                "Could not launch command \'{}\'. e = {}",
                                service_def.command, e
                            );
                            false
                        }
                    };
                    println!(
                        "function name {}, return value {return_value}",
                        service_def.function_name
                    );

                    tx.send(ServiceCommandResult {
                        service_id: service_nb,
                        success: return_value,
                    })
                    .await
                    .unwrap();

                    tokio::time::sleep(service_def.interval).await;
                }
            });
        });

    println!("All services launched");
    // config.service_definitions.

    // Main task. Listen for new result from all the tasks spawned above
    join_set.spawn(async move {
        // Move rx inside this task
        let mut rx = rx;

        loop {
            let service_command_result = rx.recv().await.unwrap();

            let (service_states_copy, should_reload) = {
                let mut service_states = service_states.lock().unwrap();
                let (new_state, should_reload) = service_states[service_command_result.service_id]
                    .update_with(
                        service_command_result.success,
                        &config.service_definitions[service_command_result.service_id],
                    );
                service_states[service_command_result.service_id] = new_state;
                (service_states.clone(), should_reload)
            };

            if should_reload {
                write_bird_function(&config, &service_states_copy);
                launch_reload_function(&config).await;
            }
        }
    });

    // No tasks should terminate (neither a service task or the main task).
    // If one does exit, this is an error
    let terminated_task: Result<!, tokio::task::JoinError> = join_set
        .join_next()
        .await
        .ok_or(eyre!("No tasks in the JoinSet ??"))?;
    let err = terminated_task.unwrap_err();
    Err(eyre!("A task failed: {}", err))
}

fn write_bird_function(config: &Config, services_states: &[ServiceState]) {
    use itertools::Itertools;
    // Combines the services static definition and their mutable state
    let services = config.service_definitions.iter().zip(services_states);
    let content = services
        .map(|(service_def, service_state)| {
            let function_name = &service_def.function_name;
            let return_value = match service_state {
                ServiceState::Failure { .. } => "false",
                ServiceState::Success { .. } => "true",
            };
            let return_type = match config.generated_file.function_return_type {
                true => "-> bool",
                false => "",
            };
            format!(
                "
function {function_name}() {return_type}
{{
    return {return_value};
}}
",
            )
        })
        .join("\n");

    let mut f = fs_err::File::create(&config.generated_file.path).unwrap();
    f.write_all(content.as_bytes()).unwrap();
}

async fn launch_reload_function(config: &Config) {
    let reload_command = Command::new(&config.reload_command)
        .args(&config.reload_command_args)
        .output();
    let reload_return_value = timeout(config.reload_timeout, reload_command).await;
    match reload_return_value {
        Ok(Ok(o)) => {
            if o.status.success() {
                println!("Reload successful");
            } else {
                println!(
                    "Reload failure. stdout = {}, stderr = {}",
                    String::from_utf8_lossy(&o.stdout),
                    String::from_utf8_lossy(&o.stderr)
                );
            }
        }
        Ok(Err(e)) => {
            println!(
                "Could not launch reload command \'{}\'. e = {}",
                config.reload_command, e
            );
        }
        Err(_) => {
            println!("Reload command timed out");
        }
    };
}
