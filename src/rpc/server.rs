use crate::{
    config::Config,
    rpc::common::Insight,
    service::{ServiceDefinition, ServiceState},
};

use futures::{future, prelude::*};

use std::{
    iter::zip,
    marker::PhantomData,
    net::{IpAddr, Ipv6Addr, SocketAddr},
    sync::Arc,
    time::Duration,
};
use tarpc::{
    context,
    server::{self, incoming::Incoming, Channel},
    tokio_serde::formats::Json,
};

// This is the type that implements the generated World trait. It is the business logic
// and is used to start the server.
#[derive(Clone)]
pub struct InsightServer {
    pub socket: SocketAddr,
    pub service_states: Arc<std::sync::Mutex<Vec<ServiceState>>>,
    pub config: Arc<Config>,
}

async fn spawn(fut: impl Future<Output = ()> + Send + 'static) {
    tokio::spawn(fut);
}
/* impl InsightServer {
    async fn new() -> anyhow::Result<Self> {
        let server_addr = (IpAddr::V6(Ipv6Addr::LOCALHOST), 50051);

        // JSON transport is provided by the json_transport tarpc module. It makes it easy
        // to start up a serde-powered json serialization strategy over TCP.
        let mut listener = tarpc::serde_transport::tcp::listen(&server_addr, Json::default).await?;
        tracing::info!("Listening on port {}", listener.local_addr().port());
        listener.config_mut().max_frame_length(usize::MAX);
        let li = listener
            // Ignore accept errors.
            .filter_map(|r| future::ready(r.ok()))
            .map(server::BaseChannel::with_defaults)
            // Limit channels to 1 per IP.
            .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
            // serve is generated by the service attribute. It takes as input any type implementing
            // the generated World trait.
            .map(|channel| {
                let server = InsightServer(channel.transport().peer_addr().unwrap());
                channel.execute(server.serve()).for_each(spawn)
            })
            // Max 10 channels.
            .buffer_unordered(10)
            .for_each(|_| async {})
            .await;
        Ok()
    }
} */
use itertools::Itertools;

impl Insight for InsightServer {
    async fn hello(self, _: context::Context, name: String) -> String {
        // let s = self
        //     .service_states
        //     .lock()
        //     .unwrap()
        //     .iter()
        //     .map(|s| format!("{:?}", s))
        //     .join(" ");

        let service_states = self.service_states.lock().unwrap();
        let services = zip(
            self.config.service_definitions.iter(),
            service_states.iter(),
        )
        .map(|(def, state)| format!("{}: {:?}", def.service_name, state))
        .join("\n");

        format!(
            "Hello, {name}! You are connected XXXX from {}, {services}",
            self.socket,
        )
    }
}
